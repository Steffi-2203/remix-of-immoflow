*** Begin Patch
*** Update File: src/services/paymentService.ts
@@
-import { db } from "../db";
-import { sql } from "drizzle-orm";
+import { db } from "../db";
+import { sql } from "drizzle-orm";
 import {
   monthlyInvoices,
   payments,
   auditLogs,
   transactions
 } from "@shared/schema";
 import { roundMoney } from "@shared/utils";
+import { optimisticUpdate } from "../src/lib/optimisticLock";
@@
       for (const inv of invoices) {
         if (remaining <= 0) break;
 
         const total = roundMoney(Number(inv.gesamtbetrag || 0));
         const paid = roundMoney(Number(inv.paid_amount || 0));
         const due = roundMoney(total - paid);
         if (due <= 0) continue;
 
         const apply = roundMoney(Math.min(remaining, due));
         const newPaid = roundMoney(paid + apply);
         remaining = roundMoney(remaining - apply);
         appliedTotal = roundMoney(appliedTotal + apply);
 
-        // Update invoice paid_amount and status, bump version
-        await tx.execute(sql`
-          UPDATE monthly_invoices
-          SET paid_amount = ${newPaid},
-              status = CASE WHEN ${newPaid} >= ${total} THEN 'bezahlt' WHEN ${newPaid} > 0 THEN 'teilbezahlt' ELSE status END,
-              version = COALESCE(version, 1) + 1,
-              updated_at = now()
-          WHERE id = ${inv.id}
-        `);
+        // Optimistic update: try versioned update with retry to avoid long locks
+        const selectSql = `SELECT id, gesamtbetrag, COALESCE(paid_amount,0) AS paid_amount, version FROM monthly_invoices WHERE id = '${inv.id}'`;
+        const updateSqlBuilder = (_newValues: any, oldVersion: number) => {
+          const status = newPaid >= total ? "bezahlt" : newPaid > 0 ? "teilbezahlt" : "offen";
+          return {
+            sql: `UPDATE monthly_invoices SET paid_amount = ${newPaid}, status = '${status}', version = ${oldVersion + 1}, updated_at = now() WHERE id = '${inv.id}' AND version = ${oldVersion}`
+          };
+        };
+
+        // run optimistic update within the current transaction (tx)
+        const optRes = await optimisticUpdate({
+          tableName: "monthly_invoices",
+          id: inv.id,
+          selectSql,
+          updateSqlBuilder,
+          maxRetries: 5,
+          delayMs: 40,
+          tx
+        });
+
+        if (!optRes.success) {
+          // Fallback: last resort, perform a FOR UPDATE update to ensure progress
+          await tx.execute(sql`
+            UPDATE monthly_invoices
+            SET paid_amount = ${newPaid},
+                status = CASE WHEN ${newPaid} >= ${total} THEN 'bezahlt' WHEN ${newPaid} > 0 THEN 'teilbezahlt' ELSE status END,
+                version = COALESCE(version, 1) + 1,
+                updated_at = now()
+            WHERE id = ${inv.id}
+          `);
+        }
 
         // Lightweight audit per allocation
         await tx.execute(sql`
           INSERT INTO audit_logs (user_id, table_name, record_id, action, new_data, created_at)
           VALUES (${userId}, 'monthly_invoices', ${inv.id}, 'payment_allocated', ${JSON.stringify({ paymentId, applied: apply })}::jsonb, now())
         `);
       }
*** End Patch
