// tools/test_harness.js
// Usage:
//   node tools/test_harness.js --year=2026 --month=9 [--run-id=RUN_ID] [--database-url=postgres://...] [--do-upsert]
// Requires: npm install minimist child_process fs-extra

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');
const argv = require('minimist')(process.argv.slice(2));

const YEAR = argv.year || '2026';
const MONTH = argv.month || '9';
const RUN_ID = argv['run-id'] || process.env.RUN_ID || '';
const DATABASE_URL = argv['database-url'] || process.env.DATABASE_URL;
const DO_UPSERT = !!argv['do-upsert'];

if (!DATABASE_URL) {
  console.error('DATABASE_URL not provided. Use --database-url or set env DATABASE_URL.');
  process.exit(1);
}

const TMP = path.resolve(process.cwd(), 'tmp');
if (!fs.existsSync(TMP)) fs.mkdirSync(TMP, { recursive: true });

function run(cmd, opts = {}) {
  console.log('> ', cmd);
  return execSync(cmd, { stdio: 'inherit', env: { ...process.env, DATABASE_URL }, ...opts });
}

try {
  // 1) Dry-run
  const dryOut = path.join(TMP, `dryrun_${YEAR}_${MONTH}.json`);
  run(`npx tsx scripts/dryrun.ts --year=${YEAR} --month=${MONTH} > ${dryOut}`);

  // 2) Generate (persist) in staging (ensure generate uses staging DB)
  const genOut = path.join(TMP, `generate_${YEAR}_${MONTH}.json`);
  run(`npx tsx scripts/generate.ts --year=${YEAR} --month=${MONTH} > ${genOut}`);

  // 3) Export persisted lines using export script or SQL
  const dbOut = path.join(TMP, `invoice_lines_run_${YEAR}_${MONTH}.json`);
  // Prefer existing export script if present
  if (fs.existsSync(path.join(process.cwd(), 'tools', 'export_db_lines.js'))) {
    run(`node tools/export_db_lines.js --run-file ${genOut} --out ${dbOut}`);
  } else {
    // Fallback: use psql to export CSV then convert to JSON (requires psql)
    const csvOut = path.join(TMP, `invoice_lines_run_${YEAR}_${MONTH}.csv`);
    const runId = RUN_ID || JSON.parse(fs.readFileSync(genOut, 'utf8')).runId;
    run(`psql "${DATABASE_URL}" -c "\\copy (SELECT invoice_id, unit_id, line_type, description, amount FROM invoice_lines WHERE invoice_id IN (SELECT id FROM monthly_invoices WHERE run_id='${runId}') ORDER BY invoice_id) TO '${csvOut}' WITH CSV HEADER"`);
    // Convert CSV to JSON (simple)
    const csv = fs.readFileSync(csvOut, 'utf8').trim().split('\\n');
    const headers = csv.shift().split(',');
    const rows = csv.map(line => {
      const cols = line.split(',');
      const obj = {};
      headers.forEach((h, i) => obj[h] = cols[i]);
      return obj;
    });
    fs.writeFileSync(dbOut, JSON.stringify(rows, null, 2));
  }

  // 4) Compare dry-run vs DB using existing find_missing_lines.js
  // Ensure find_missing_lines.js supports optional args; if not, copy files to expected names
  const expectedDry = path.join(process.cwd(), 'dryrun.json');
  const expectedDb = path.join(process.cwd(), 'invoice_lines_run.json');
  fs.copyFileSync(dryOut, expectedDry);
  fs.copyFileSync(dbOut, expectedDb);

  run(`node tools/find_missing_lines.js`);

  const missingCsv = path.join(process.cwd(), 'missing_lines.csv');
  const missingExists = fs.existsSync(missingCsv) && fs.readFileSync(missingCsv, 'utf8').trim().length > 0;
  if (!missingExists) {
    console.log('No missing lines detected. Dryâ€‘Run and Persist are in parity.');
  } else {
    console.warn('Missing lines detected. See missing_lines.csv for details.');
    if (DO_UPSERT) {
      // Dry-run upsert first
      run(`node tools/upsert_missing_lines.js --csv=${missingCsv} --run-id=${RUN_ID} --database-url="${DATABASE_URL}" --dry-run`);
      // Confirm and run real upsert
      console.log('Proceeding with real upsert (batches will be transactional).');
      run(`node tools/upsert_missing_lines.js --csv=${missingCsv} --run-id=${RUN_ID} --database-url="${DATABASE_URL}"`);
      console.log('Upsert completed. Recomputing totals for affected invoices.');
      run(`psql "${DATABASE_URL}" -c "UPDATE monthly_invoices mi SET total_amount = s.new_sum, updated_at = now() FROM (SELECT mi2.id AS invoice_id, COALESCE(ROUND(SUM(il.amount)::numeric,2),0) AS new_sum FROM monthly_invoices mi2 LEFT JOIN invoice_lines il ON il.invoice_id = mi2.id WHERE mi2.run_id = '${RUN_ID}' GROUP BY mi2.id) s WHERE mi.id = s.invoice_id AND (mi.total_amount IS DISTINCT FROM s.new_sum);"`);
    } else {
      console.log('Upsert not executed. Rerun with --do-upsert to apply fixes.');
    }
  }

  console.log('Integration harness finished.');
} catch (err) {
  console.error('Harness failed:', err);
  process.exit(1);
}
