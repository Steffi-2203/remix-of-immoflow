// src/services/paymentService.ts
import { db } from "../db";
import { sql } from "drizzle-orm";
import {
  monthlyInvoices,
  payments,
  auditLogs,
  transactions
} from "@shared/schema";
import { roundMoney } from "@shared/utils";

/**
 * PaymentService
 * - allocatePayment: idempotent insert + row-level locking + allocation order BK -> HK -> Miete
 * - getTenantBalance: sums gesamtbetrag and paid_amount
 * - getDunningLevel / recordDunningAction: simple helpers for Mahnwesen
 */
export class PaymentService {
  async allocatePayment(params: {
    paymentId: string;
    tenantId: string;
    amount: number;
    bookingDate?: string; // YYYY-MM-DD
    paymentType?: string;
    reference?: string;
    userId?: string;
  }) {
    const {
      paymentId,
      tenantId,
      amount,
      bookingDate,
      paymentType = "ueberweisung",
      reference,
      userId
    } = params;

    const roundedAmount = roundMoney(amount);

    return await db.transaction(async (tx) => {
      // 1) Insert payment record idempotent
      await tx.execute(sql`
        INSERT INTO payments (id, tenant_id, invoice_id, betrag, buchungs_datum, payment_type, verwendungszweck, created_at)
        VALUES (${paymentId}, ${tenantId}, NULL, ${roundedAmount}, ${bookingDate ?? sql`now()::date`}, ${paymentType}, ${reference}, now())
        ON CONFLICT (id) DO NOTHING
      `);

      // 2) Lock open invoices for tenant ordered oldest first
      const locked = await tx.execute(sql`
        SELECT id, gesamtbetrag, COALESCE(paid_amount, 0) AS paid_amount
        FROM monthly_invoices
        WHERE tenant_id = ${tenantId} AND status IN ('offen','teilbezahlt')
        ORDER BY year, month
        FOR UPDATE
      `);
      const invoices = locked.rows;

      let remaining = roundedAmount;
      let appliedTotal = 0;

      for (const inv of invoices) {
        if (remaining <= 0) break;

        const total = roundMoney(Number(inv.gesamtbetrag || 0));
        const paid = roundMoney(Number(inv.paid_amount || 0));
        const due = roundMoney(total - paid);
        if (due <= 0) continue;

        const apply = roundMoney(Math.min(remaining, due));
        const newPaid = roundMoney(paid + apply);
        remaining = roundMoney(remaining - apply);
        appliedTotal = roundMoney(appliedTotal + apply);

        // Update invoice paid_amount and status, bump version
        await tx.execute(sql`
          UPDATE monthly_invoices
          SET paid_amount = ${newPaid},
              status = CASE WHEN ${newPaid} >= ${total} THEN 'bezahlt' WHEN ${newPaid} > 0 THEN 'teilbezahlt' ELSE status END,
              version = COALESCE(version, 1) + 1,
              updated_at = now()
          WHERE id = ${inv.id}
        `);

        // Lightweight audit per allocation
        await tx.execute(sql`
          INSERT INTO audit_logs (user_id, table_name, record_id, action, new_data, created_at)
          VALUES (${userId}, 'monthly_invoices', ${inv.id}, 'payment_allocated', ${JSON.stringify({ paymentId, applied: apply })}::jsonb, now())
        `);
      }

      // 3) Handle remaining amount (overpayment)
      let unapplied = remaining;
      if (unapplied > 0) {
        // Create a credit transaction record
        await tx.execute(sql`
          INSERT INTO transactions (id, organization_id, bank_account_id, amount, transaction_date, booking_text, created_at)
          VALUES (gen_random_uuid(), NULL, NULL, ${unapplied}, now()::date, ${`Überzahlung / Gutschrift für Tenant ${tenantId}`}, now())
        `);

        // Annotate payment with note about overpayment
        await tx.execute(sql`
          UPDATE payments
          SET notizen = COALESCE(notizen, '') || ${` Überzahlung ${unapplied.toFixed(2)} €`}, updated_at = now()
          WHERE id = ${paymentId}
        `);
      }

      // 4) Summary audit for the payment
      await tx.execute(sql`
        INSERT INTO audit_logs (user_id, table_name, record_id, action, new_data, created_at)
        VALUES (${userId}, 'payments', ${paymentId}, 'allocated', ${JSON.stringify({
          tenantId,
          paymentId,
          amount: roundedAmount,
          applied: appliedTotal,
          unapplied
        })}::jsonb, now())
      `);

      return {
        success: true,
        paymentId,
        applied: appliedTotal,
        unapplied
      };
    });
  }

  async getTenantBalance(tenantId: string, year?: number) {
    const yearClause = year ? sql`AND year = ${year}` : sql``;
    const res = await db.execute(sql`
      SELECT COALESCE(SUM(gesamtbetrag),0) AS total_soll, COALESCE(SUM(paid_amount),0) AS total_ist
      FROM monthly_invoices
      WHERE tenant_id = ${tenantId} ${yearClause}
    `);
    const row = res.rows[0] || { total_soll: 0, total_ist: 0 };
    const totalSoll = roundMoney(Number(row.total_soll || 0));
    const totalIst = roundMoney(Number(row.total_ist || 0));
    return { totalSoll, totalIst, saldo: roundMoney(totalSoll - totalIst) };
  }

  getDunningLevel(daysOverdue: number) {
    if (daysOverdue >= 45) return 3;
    if (daysOverdue >= 30) return 2;
    if (daysOverdue >= 14) return 1;
    return 0;
  }

  async recordDunningAction(params: { tenantId: string; level: number; userId?: string; note?: string }) {
    const { tenantId, level, userId, note } = params;
    await db.insert(auditLogs).values({
      userId,
      tableName: "tenants",
      recordId: tenantId,
      action: `dunning_level_${level}`,
      newData: { note, level },
      createdAt: new Date()
    });
  }
}

export const paymentService = new PaymentService();
